-DROP PROCEDURE TYJINFWLIB.SP_TGCSI_CSG1010_GETTEXT;
  
CREATE PROCEDURE TYJINFWLIB.SP_TGCSI_CSG1010_GETTEXT ( 
	IN P_CURRENTPAGEINDEX INTEGER , 
	IN P_PAGESIZE INTEGER , 
	IN P_COMPANY VARCHAR(20) , 
	IN P_HANGCHA VARCHAR(7) , 
	IN P_GOKJONG VARCHAR(2) ) 
	DYNAMIC RESULT SETS 2 
	LANGUAGE SQL 
	SPECIFIC TYJINFWLIB.SP_TGCSI_CSG1010_GETTEXT 
	NOT DETERMINISTIC 
	MODIFIES SQL DATA 
	CALLED ON NULL INPUT 
	SET OPTION  ALWBLK = *ALLREAD , 
	ALWCPYDTA = *OPTIMIZE , 
	COMMIT = *NONE , 
	DECRESULT = (31, 31, 00) , 
	DYNDFTCOL = *NO , 
	DYNUSRPRF = *USER , 
	SRTSEQ = *HEX   
	P1 : BEGIN  -- 시작 
	DECLARE P_STNUM INTEGER ; 
	DECLARE P_FNNUM INTEGER ; 
	DECLARE P_SQLSTRING VARCHAR ( 4000 ) ; 
	DECLARE P_SQLTOTALROWCOUNT VARCHAR ( 4000 ) ; 
	DECLARE P_TABLE_QUERY			VARCHAR ( 5000 ) ; 
	DECLARE P_COUNT_QUERY			VARCHAR ( 5000 ) ; 
  
	PREV : BEGIN  -- 값 설정 
		SET P_STNUM = ( P_PAGESIZE * ( P_CURRENTPAGEINDEX - 1 ) ) + 1 ; 
	SET P_FNNUM = P_PAGESIZE * P_CURRENTPAGEINDEX ; 
	END PREV ; 
  
	MAIN : BEGIN  -- 실행부      
		IF P_COMPANY = '그레인' THEN 
  
			LIST_T : BEGIN  -- 리스트 
				DECLARE REFCURSOR_T CURSOR WITH RETURN FOR 
  
					WITH ORIGINAL_DATA AS 
					( 
						SELECT 
						ROW_NUMBER ( ) OVER ( ) AS ROWNO , 
						IHHANGCHA , 
						VSCODE . CDDESC1 AS VSDESC1 , 
						IHIPHANG , 
						IPGOKJONG , 
						GKCODE . CDDESC1 AS GKDESC1 , 
						SKCODE . CDDESC1 AS SKDESC1 , 
						IHBLQTY , 
						IPTOTQTY 
						FROM TGSCMLIB . USIIPGOF AS IPGO 
						LEFT OUTER JOIN TGSCMLIB . USIIPHAF AS IPHA 
						ON IPGO . IPHANGCHA = IPHA . IHHANGCHA 
						LEFT OUTER JOIN TGSCMLIB . USICODEF AS GKCODE 
						ON 'GK' = GKCODE . CDINDEX 
						AND IPGO . IPGOKJONG = GKCODE . CDCODE 
						LEFT OUTER JOIN TGSCMLIB . USICODEF AS SKCODE 
						ON 'SK' = SKCODE . CDINDEX 
						AND IPHA . IHSOSOK = SKCODE . CDCODE 
						LEFT OUTER JOIN TGSCMLIB . USICODEF AS VSCODE 
						ON 'VS' = VSCODE . CDINDEX 
						AND IPHA . IHHANGCHA = VSCODE . CDCODE 
						WHERE IPHANGCHA = P_HANGCHA 
						AND IPGOKJONG = P_GOKJONG 
					) 
  
					SELECT 
					* 
					FROM ORIGINAL_DATA AS A 
					WHERE ROWNO BETWEEN CAST ( P_STNUM AS VARCHAR ( 100 ) ) AND CAST ( P_FNNUM AS VARCHAR ( 100 ) ) 
					ORDER BY ROWNO ASC ; 
  
				OPEN REFCURSOR_T ; 
  
			END LIST_T ; 
  
			PAGING_T : BEGIN  -- 페이징 
				DECLARE REFCURSOR_T CURSOR WITH RETURN FOR 
  
					SELECT 
					COUNT ( * ) AS TOTALCOUNT 
					FROM TGSCMLIB . USIIPHAF AS IPHA 
					WHERE IHHANGCHA = P_HANGCHA ; 
  
				OPEN REFCURSOR_T ; 
  
			END PAGING_T ; 
  
		ELSE			 
			 
			LIST_P : BEGIN  -- 리스트 
				DECLARE REFCURSOR_P CURSOR WITH RETURN FOR 
  
					WITH ORIGINAL_DATA AS 
					( 
						SELECT 
						ROW_NUMBER ( ) OVER ( ) AS ROWNO , 
						IHHANGCHA , 
						VSCODE . CDDESC1 AS VSDESC1 , 
						IHIPHANG , 
						IPGOKJONG , 
						GKCODE . CDDESC1 AS GKDESC1 , 
						SKCODE . CDDESC1 AS SKDESC1 , 
						IHBLQTY , 
						IPTOTQTY 
						FROM PTSCMLIB . USIIPGOF AS IPGO 
						LEFT OUTER JOIN PTSCMLIB . USIIPHAF AS IPHA 
						ON IPGO . IPHANGCHA = IPHA . IHHANGCHA 
						LEFT OUTER JOIN TGSCMLIB . USICODEF AS GKCODE 
						ON 'GK' = GKCODE . CDINDEX 
						AND IPGO . IPGOKJONG = GKCODE . CDCODE 
						LEFT OUTER JOIN TGSCMLIB . USICODEF AS SKCODE 
						ON 'SK' = SKCODE . CDINDEX 
						AND IPHA . IHSOSOK = SKCODE . CDCODE 
						LEFT OUTER JOIN TGSCMLIB . USICODEF AS VSCODE 
						ON 'VP' = VSCODE . CDINDEX 
						AND IPHA . IHHANGCHA = VSCODE . CDCODE 
						WHERE IPHANGCHA = P_HANGCHA 
						AND IPGOKJONG = P_GOKJONG 
					) 
  
					SELECT 
					* 
					FROM ORIGINAL_DATA AS A 
					WHERE ROWNO BETWEEN CAST ( P_STNUM AS VARCHAR ( 100 ) ) AND CAST ( P_FNNUM AS VARCHAR ( 100 ) ) 
					ORDER BY ROWNO ASC ; 
  
				OPEN REFCURSOR_P ; 
  
			END LIST_P ; 
  
			PAGING_P : BEGIN  -- 페이징 
				DECLARE REFCURSOR_P CURSOR WITH RETURN FOR 
  
					SELECT 
					COUNT ( * ) AS TOTALCOUNT 
					FROM TGSCMLIB . USIIPHAF AS IPHA 
					WHERE IHHANGCHA = P_HANGCHA ; 
  
				OPEN REFCURSOR_P ; 
  
			END PAGING_P ; 
  
		END IF ; 
  
	END MAIN ; 
END P1  ; 
  

